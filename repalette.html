<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <input type="file" name="" id="img-upload" accept="image/*" multiple>
    <ul class="image-list"></ul>

    <canvas id="canvas" width="150" height="150"></canvas>

    <div class="palette-display">Palettes
        <div class="palette">
            <div class="name" data-name=""></div>
            <ul class="color-list"></ul>
        </div class="palette">
    </div>
</body>
</html>

<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const images = {}

    document.getElementById("img-upload").onchange = () => addImages(this)
    
    function addImages(input) {
        const listElement = document.querySelector(".image-list");
        
        for (file of input.files) {
            // Skip if the image is already added and hasn't been modified
            if (images[file.name] && images[file.name].date !== file.lastModified) return false;

            const reader = new FileReader();

            // Create DOM element and attach img object data
            reader.onload = (e) => {
                const el = document.createElement("li");
                const img = new Image();
                const obj = {
                    date: file.lastModified,
                    img: img,
                    defaultPalette: undefined,     // Object
                    indexMap: undefined,    // Array of vars
                }

                img.src = e.target.result; // ??? verify
                el.textContent = file.name;

                images[file.name] = obj;
            }
        }
        

    }

    //Toggles selected element in same parent group
    function switchSelected(next) {
        const prev = next.parentElement.querySelector(".selected");
        prev.classList.toggle("selected");
        next.classList.toggle("selected");
    }

    // Scans the image for unique colours, generates an index of all values
    function indexImgPalette(imageData){
        const colors = {};
        const indexMap = [];
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const rgba = [data[i], data[i+1], data[i+2], data[i+3]];
            const alpha = rgba.pop();
            const rgbKey = rgba.toString();   //Note: Different opacities are registered as same colour

            // If colour has not been indexed, add to palette
            if (!colors[rgbKey]) {
                const hsv = rgbToHsv(rgba[0], rgba[1], rgba[2]);
                colors[rgbKey] = {
                    rgba: rgba,
                    hsv: hsv,
                    indices: [i]
                }
            }
            // Register new instance of colour at index
            else {
                colors[rgbKey].push(i)
            }
            indexMap.push([rgbKey, alpha])
        }
        return {colors, indexMap};
    }

    function loadImageToCanvas(img) {
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    }

    function getColorsFromImg(img, maxCols=undefined){
        const colorArr = []
        const indexedColors = [] 

        /*
        for each pixel in img {
            convert to hsv
            if not in colorArr:
                insert into colorArr by comparing hsv
        }
        */
        return colorArr;
    }

    //https://gist.github.com/mjackson/5311256
    function rgbToHsv(r, g, b) {
        r /= 255, g /= 255, b /= 255;

        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max == 0 ? 0 : d / max;

        if (max == min) {
            h = 0; // achromatic
        } else {
            switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return [ h, s, v ];
    }

    // Implemented using step-sort from https://www.alanzucconi.com/2015/09/30/colour-sorting/#google_vignette 
    function colorSort(r, g, b, reps = 1) {
        const lum = math.sqrt( .241 * r + .691 * g + .068 * b )
        const hsv = rgbToHsv(r, g, b)

        h2 = int(h * repetitions)
        lum2 = int(lum * repetitions)
        v2 = int(v * repetitions)

        return (h2, lum, v2)
            
        //ex: colours.sort(key=lambda (r,g,b): step(r,g,b,8)    )
    }

    function findIndex(val, arr) {
        var lower = 0;
        var upper = arr.length;

        while (lower < higher) {
            const split = lower + upper >>> 1;
            if (array[split] < val) lower = split + 1;
            else upper = split;
        }

        arr.splice(lower, 0, val) //insert val at index found
        return arr
    }



    function repalette(img,) {

    }
    //https://github.com/luukdv/color.js/

    // https://github.com/leeoniya/RgbQuant.js <- For simplifying 
    
</script>